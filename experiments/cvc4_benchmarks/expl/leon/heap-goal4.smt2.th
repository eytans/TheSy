(datatype Nat () ((succ Nat Nat) (zero Nat)))
(datatype Lst () ((cons Nat Lst Lst) (nil Lst)))
(datatype Heap () ((hleaf Heap) (heap Nat Nat Heap Heap Heap)))
(declare-fun less (Nat Nat) Bool)
(declare-fun plus (Nat Nat) Nat)
(declare-fun len (Lst) Nat)
(declare-fun rsorted (Lst) Bool)
(declare-fun sorted (Lst) Bool)
(declare-fun rightHeight (Heap) Nat)
(declare-fun rank (Heap) Nat)
(declare-fun hasLeftistProperty (Heap) Bool)
(declare-fun hsize (Heap) Nat)
(declare-fun mergea (Nat Heap Heap) Heap)
(declare-fun merge (Heap Heap) Heap)
(declare-fun hinsert (Heap Nat) Heap)
(declare-fun hinsert-all (Lst Heap) Heap)
(declare-fun qheapsorta (Heap Lst) Lst)
(declare-fun qheapsort (Lst) Lst)
(declare-fun heapsorta (Heap) Lst)
(declare-fun heapsort (Lst) Lst)
(<=> rule0 (less zero zero) false)
(=> rule1 (less zero (succ ?x)) true)
(=> rule2 (less (succ ?x) (succ ?y)) (less ?x ?y))
(=> rule3 (less ?x ?y) (less (succ ?x) (succ ?y)))
(declare-fun leq (Nat Nat) Bool)
(=> rule4 (leq ?__x0 ?__y1) (or (= ?__x0 ?__y1) (less ?__x0 ?__y1)))
(=> rule5 (or (= ?__x0 ?__y1) (less ?__x0 ?__y1)) (leq ?__x0 ?__y1))
(=> rule6 (plus zero ?n) ?n)
(=> rule7 (plus (succ ?n) ?m) (succ (plus ?n ?m)))
(=> rule8 (succ (plus ?n ?m)) (plus (succ ?n) ?m))
(=> rule9 (len nil) zero)
(=> rule10 zero (len nil))
(=> rule11 (len (cons ?x ?y2)) (succ (len ?y2)))
(<=> rule12 (rsorted nil) true)
(=> rule13 (rsorted (cons ?x nil)) true)
(=> rule14 (rsorted (cons ?x (cons ?z ?y3))) (and (rsorted (cons ?z ?y3)) (or (= ?z ?x) (less ?z ?x))))
(=> rule15 (and (rsorted (cons ?z ?y3)) (or (= ?z ?x) (less ?z ?x))) (rsorted (cons ?x (cons ?z ?y3))))
(<=> rule16 (sorted nil) true)
(=> rule17 (sorted (cons ?x nil)) true)
(=> rule18 (sorted (cons ?x (cons ?z ?y4))) (and (rsorted (cons ?z ?y4)) (or (= ?x ?z) (less ?x ?z))))
(=> rule19 (and (rsorted (cons ?z ?y4)) (or (= ?x ?z) (less ?x ?z))) (sorted (cons ?x (cons ?z ?y4))))
(=> rule20 (rightHeight hleaf) zero)
(=> rule21 zero (rightHeight hleaf))
(=> rule22 (rightHeight (heap ?k ?v ?l ?r)) (succ (rightHeight ?r)))
(=> rule23 (rank hleaf) zero)
(=> rule24 zero (rank hleaf))
(=> rule25 (rank (heap ?k ?v ?l ?r)) ?k)
(<=> rule26 (hasLeftistProperty hleaf) true)
(=> rule27 (hasLeftistProperty (heap ?k ?v ?l ?r)) (and (hasLeftistProperty ?l) (hasLeftistProperty ?r) (or (= (rightHeight ?r) (rightHeight ?l)) (less (rightHeight ?r) (rightHeight ?l))) (= ?k (succ (rightHeight ?r)))))
(=> rule28 (hsize hleaf) zero)
(=> rule29 zero (hsize hleaf))
(=> rule30 (hsize (heap ?k ?v ?l ?r)) (succ (plus (hsize ?l) (hsize ?r))))
(=> rule31 (mergea ?v ?l ?r) (ite (or (= (rank ?r) (rank ?l)) (less (rank ?r) (rank ?l))) (heap (succ (rank ?r)) ?v ?l ?r) (heap (succ (rank ?l)) ?v ?r ?l)))
(=> rule32 (ite (or (= (rank ?r) (rank ?l)) (less (rank ?r) (rank ?l))) (heap (succ (rank ?r)) ?v ?l ?r) (heap (succ (rank ?l)) ?v ?r ?l)) (mergea ?v ?l ?r))
(=> rule33 (merge ?h hleaf) ?h)
(=> rule34 (merge hleaf ?h) ?h)
(=> rule35 (merge (heap ?k1 ?v1 ?l1 ?r1) (heap ?k2 ?v2 ?l2 ?r2)) (ite (less ?v2 ?v1) (mergea ?v1 ?l1 (merge ?r1 (heap ?k2 ?v2 ?l2 ?r2))) (mergea ?v2 ?l2 (merge (heap ?k1 ?v1 ?l1 ?r1) ?r2))))
(=> rule36 (ite (less ?v2 ?v1) (mergea ?v1 ?l1 (merge ?r1 (heap ?k2 ?v2 ?l2 ?r2))) (mergea ?v2 ?l2 (merge (heap ?k1 ?v1 ?l1 ?r1) ?r2))) (merge (heap ?k1 ?v1 ?l1 ?r1) (heap ?k2 ?v2 ?l2 ?r2)))
(=> rule37 (hinsert ?h ?n) (merge (heap (succ zero) ?n hleaf hleaf) ?h))
(=> rule38 (merge (heap (succ zero) ?n hleaf hleaf) ?h) (hinsert ?h ?n))
(=> rule39 (hinsert-all nil ?h) ?h)
(=> rule40 (hinsert-all (cons ?n ?l5) ?h) (hinsert (hinsert-all ?l5 ?h) ?n))
(=> rule41 (hinsert (hinsert-all ?l5 ?h) ?n) (hinsert-all (cons ?n ?l5) ?h))
(=> rule42 (qheapsorta hleaf ?l6) ?l6)
(=> rule43 (qheapsorta (heap ?k ?v ?l ?r) ?x7) (qheapsorta (merge ?l ?r) (cons ?v ?x7)))
(=> rule44 (qheapsort ?l8) (qheapsorta (hinsert-all ?l8 hleaf) nil))
(=> rule45 (qheapsorta (hinsert-all ?l8 hleaf) nil) (qheapsort ?l8))
(=> rule46 (heapsorta hleaf) nil)
(=> rule47 nil (heapsorta hleaf))
(=> rule48 (heapsorta (heap ?k ?v ?l ?r)) (cons ?v (heapsorta (merge ?l ?r))))
(=> rule49 (heapsort ?l9) (heapsorta (hinsert-all ?l9 hleaf)))
(=> rule50 (heapsorta (hinsert-all ?l9 hleaf)) (heapsort ?l9))
(=> rule51 (=> (hasLeftistProperty x10) (= (hasLeftistProperty (hinsert ?x10 ?n)) true)))
(=> rule52 (=> (hasLeftistProperty x12) (= (hasLeftistProperty (hinsert-all ?n11 ?x12)) true)))
(=> rule53 (=> (and (hasLeftistProperty x13) (hasLeftistProperty y14)) (= (hasLeftistProperty (mergea ?v ?x13 ?y14)) true)))
(prove (forall ((x15 Heap)(y16 Heap)) (=> (and (hasLeftistProperty x15) (hasLeftistProperty y16)) (hasLeftistProperty (merge x15 y16)))))
