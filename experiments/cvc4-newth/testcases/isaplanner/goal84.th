datatype Nat () := (succ : (x_0 : Nat) -> (res : Nat)) (zero : (res : Nat))
datatype Lst () := (cons : (x_0 : Nat) -> (x_1 : Lst) -> (res : Lst)) (nil : (res : Lst))
datatype Pair () := (mkpair : (x_0 : Nat) -> (x_1 : Nat) -> (res : Pair))
datatype ZLst () := (zcons : (x_0 : Pair) -> (x_1 : ZLst) -> (res : ZLst)) (znil : (res : ZLst))
fun take (x_0 : Nat) (x_1 : Lst) -> Lst
fun zip (x_0 : Lst) (x_1 : Lst) -> ZLst
fun ztake (x_0 : Nat) (x_1 : ZLst) -> ZLst
fun leq (__x0 : Nat) (__y1 : Nat) -> Bool => (or (= ?__x0 ?__y1) (less ?__x0 ?__y1))
rw rule0 (take ?x nil) => nil
rw rule1 (take zero ?x2) => nil
rw rule2 (take (succ ?x) (cons ?y ?z)) => (cons ?y (take ?x ?z))
rw rule3 (cons ?y (take ?x ?z)) => (take (succ ?x) (cons ?y ?z))
rw rule4 (zip nil ?x3) => znil
rw rule5 (zip ?x4 nil) => znil
rw rule6 (zip (cons ?x ?y5) (cons ?z6 ?w)) => (zcons (mkpair ?x ?z6) (zip ?y5 ?w))
rw rule7 (zcons (mkpair ?x ?z6) (zip ?y5 ?w)) => (zip (cons ?x ?y5) (cons ?z6 ?w))
rw rule8 (ztake ?x znil) => znil
rw rule9 (ztake zero ?x7) => znil
rw rule10 (ztake (succ ?x) (zcons ?y8 ?z9)) => (zcons ?y8 (ztake ?x ?z9))
rw rule11 (zcons ?y8 (ztake ?x ?z9)) => (ztake (succ ?x) (zcons ?y8 ?z9))
prove (ztake (?n : Nat) (zip (?xs : Lst) (?ys : Lst)))  = (zip (take (?n : Nat) (?xs : Lst)) (take (?n : Nat) (?ys : Lst)))
